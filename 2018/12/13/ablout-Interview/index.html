
<!DOCTYPE html>
<html lang="" class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SuMMerHeart - I Know,I Know</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="活像个孤独患者 自我拉扯,vuex中this引用（弹窗信息）
import Vue from ‘vue’
var v = new Vue() ;
v.$Message.error(res.data.message);

数组,"> 
    <meta name="author" content="Fuzb"> 
    <link rel="alternative" href="atom.xml" title="SuMMerHeart" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.ico"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
</head>
</html>
<body class="loading">
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">关于面试</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>
    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">关于面试</h1>
        <div class="stuff">
            <span>十二月 13, 2018</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Hellow-New-Job/">Hellow New Job!</a></li></ul>


        </div>
        <div class="content markdown">
            <h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li>js不是面向对象语言。学习面向对象思想 是为了模拟其编程思想，实现代码的复用。</li>
<li>面向过程：<ul>
<li>要按部就班的书写代码，有些代码的书写顺序不能改变。</li>
<li>缺点：难以维护、难以扩展、代码复用</li>
</ul>
</li>
<li>面向对象：<ul>
<li>在实际开发解决一个问题时，首先看是否已存在一个对象可以帮助解决，如果有，就使用该对象解决问题；</li>
<li>如果没有，就实现一个对象去解决该问题，以后如果在遇到同类问题，就可以找到该对象来解决。</li>
<li>优点：实现代码复用</li>
</ul>
</li>
<li>两者区别<ul>
<li>身份：<ul>
<li>前者 –&gt; 执行者; </li>
<li>后者 –&gt; 管理者  </li>
</ul>
</li>
<li>实现：<ul>
<li>前者：亲力亲为，按部就班的实现</li>
<li>后者：在实现功能时，可以交给其他对象去完成。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>概念：就是指 函数的prototype属性引用的对象</li>
<li>作用：为同类对象共享数据（包括属性和方法）</li>
<li>对象的原型 就是 它构造函数的prototype属性</li>
<li>本质：原型 是 对象类型；<ul>
<li>当创建函数时，就已经创建原型–js解析器创建的默认原型，会给默认原型添加一个constructor属性，该属性指回函数。</li>
<li>如果手动替换掉了默认的原型，那么constructor属性会丢失。此时，若该属性具有一定的开发意义，就将其手动添加上，并且给其正确的指向。</li>
</ul>
</li>
<li>实现继承：如果想要一个对象a 继承自 另外一个对象b，那么就让a对象的原型 是 对象b即可。</li>
<li>继承实现方式<ul>
<li>原型式:<ul>
<li>a.在默认原型上 去添加 想要访问的属性和要调用的方法;</li>
<li>b.将默认的原型,替换掉。然后原型变成一个新的对象，之后创建的对象，就继承自新的原型。</li>
</ul>
</li>
<li>混入式：从jQuery的extend方法里总结的一种继承实现</li>
<li>代码实现：<ul>
<li>1.获取对象a的构造函数，给该构造函数的prototype属性赋值为 对象b。</li>
<li><ol start="2">
<li>获取对象a的构造函数，通过prototype属性获取到a对象的原型，把对象b的所有属性和方法，添加给原型。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>获取原型的方式<ul>
<li>构造函数：<fn>.prototype</fn></li>
<li>对象:<object>.__proto__ (非标准属性)获取对象的原型，即该对象所继承的对象</object></li>
</ul>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>本质：对象的非标准属性__proto__</li>
<li>作用：认清对象的继承层次关系</li>
<li>概念：从对象出发到Object.prototype之间存在一条,由非标准属性__proto__串联起来的，体现继承层次的链式结构。该结构被称为 对象的原型链。</li>
<li>所有原型 默认的原型 都是Object.prototype</li>
<li>在js中，利用原型可以实现 面向对象语言中的 单继承；如果想实现多继承，可以配合其他的继承方式；譬如混入式继承、寄生、组合继承、借用构造函数…</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>变量的种类<ul>
<li>全局变量：在script标签内定义的变量，或者不在任何函数内定义的变量。</li>
<li>局部变量：在函数内部定义的变量，只能在函数内部使用，出了函数之外，该变量就是未定义的。</li>
</ul>
</li>
<li>变量的作用域<ul>
<li>就是指：变量可以被访问到的区域，该区域称之为，变量的作用域；如果不在该区域访问变量，就会抛出异常，（xxx is not defined）</li>
</ul>
</li>
<li>作用域的种类—在js中有两个作用域：<ul>
<li>全局作用域</li>
<li>局部作用域</li>
</ul>
</li>
<li>作用域规则：在所有开发语言中，作用域的规则大致分为 两类：<ul>
<li>静态作用域 – 词法作用域 js <ul>
<li>在js代码编译时，通过静态分析，在代码执行之前来确定变量的作用域。</li>
</ul>
</li>
<li>动态作用域 – java .net swift object-c </li>
</ul>
</li>
</ul>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><ul>
<li>描述：变量的作用域,是由变量定义的位置决定的,而不是由其使用的位置决定。在词法作用域中只有函数可以限定作用域。在js预解析阶段，会将变量声明以及函数声明提升。</li>
<li>预解析阶段：为了提高js代码的执行效率<ul>
<li>词法分析：检测书写js代码 是否满足 ECMAScript制定语法规则。如果不满足语法规则，就会在该阶段抛出异常。由于预解析阶段,早于代码的执行，所以此时无法加断点调试。</li>
<li>变量声明以及函数声明的提升</li>
</ul>
</li>
</ul>
<h3 id="作用链域"><a href="#作用链域" class="headerlink" title="作用链域"></a>作用链域</h3><ul>
<li>函数是可以嵌套使用的，而函数又能够限定作用域。因此，函数在嵌套使用，会产生局部作用域里有包含其他局部作用域。那么 为了清晰描述各个局部作用域，就引出作用域链的概念。</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>简单的理解是函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域</li>
<li>使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值</li>
<li>缺点–因此，闭包的作用也是他的缺点。滥用闭包结构，会增大内存的开销，也有可能会造成内存泄漏。</li>
<li>改进–为了在使用闭包时，会造成内存泄漏的问题，所以通常在使用完闭包后，将变量赋值为 null。</li>
</ul>
<h3 id="cookies，sessionStorage和localStorage的区别"><a href="#cookies，sessionStorage和localStorage的区别" class="headerlink" title="cookies，sessionStorage和localStorage的区别"></a>cookies，sessionStorage和localStorage的区别</h3><ul>
<li>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li>
<li>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</li>
<li>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>动态创建script</li>
<li>jsonp</li>
<li>cors</li>
<li>location.hash</li>
<li>window.name+iframe</li>
<li>document.domain</li>
<li>postMessage</li>
<li>反向代理—–相当于浏览器发请求到代理服务器，服务器配置关闭正向代理，开启反向代理，我们再跨域访问时，使用其他标识代替想要跨域的接口路径，然后再发ajax的时候，相当于反向代理服务器拦截到了请求，它会帮我们发请求到目标服务器，请求回数据再返给我们浏览器，相当于反向代理服务器是一个桥梁</li>
</ul>
<h3 id="MVC-和-MVVM"><a href="#MVC-和-MVVM" class="headerlink" title="MVC 和 MVVM"></a>MVC 和 MVVM</h3><ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Controller）：业务逻辑</li>
<li>模型（Model）：数据保存</li>
</ul>
<p><strong>所有通信都是单向的</strong>    </p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<ul>
<li>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model），有几大优点</li>
</ul>
<ol>
<li>低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>
<li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li>
</ol>
<h3 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h3><ul>
<li>核心 组件化 -&gt; 自定义指令也可以认为是组件(让其不太依赖于存在的环境，尽量独立，通过参数)</li>
<li>双向数据绑定 -&gt;  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    数据劫持 ES5 中的 Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">    //设置</span><br><span class="line">    set:function()&#123;   obj.name =&apos;1234&apos;;//触发该函数</span><br><span class="line">        //做相关操作,(改变DOM中跟name挂钩的元素的value)</span><br><span class="line">    &#125;,</span><br><span class="line">    get:function()&#123;  //obj.name 就会触发</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><ul>
<li>从页面的改变影响内存 ，单向数据流</li>
<li>从内存的改变影响页面 ，单向数据流</li>
<li>两者都具备，双向数据流( 数据劫持-&gt; ES5 -&gt; Object.defineProperty(obj,paramName,{set:fn,get:fn}))</li>
</ul>
<h4 id="解决闪烁问题"><a href="#解决闪烁问题" class="headerlink" title="解决闪烁问题"></a>解决闪烁问题</h4><ul>
<li>在引库的方式中存在闪烁问题，在单文件方式中不会有该问题，提前编译好html内容</li>
<li>v-text 插入innerText</li>
<li>v-cloak 待测试</li>
</ul>
<h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><ul>
<li>v-if 是移除与否的问题</li>
<li>v-show 是隐藏与否的问题</li>
<li>v-model 双向数据绑定，绑定的是value</li>
<li>v-bind —  <strong>:</strong> 可以让vue对象进行运算，并将最终的动态结果赋值给该属性</li>
<li>v-on —- <strong>@</strong>  绑定事件 @click=”函数(xxx)”<h4 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h4></li>
<li>父向子<ul>
<li>常量:  子组件上属性 msg=”xxx”  子组件声明根属性props:[‘msg’]</li>
<li>变量:  :msg=”obj”</li>
<li>在js部分通过实例对象使用，this.$props.msg</li>
</ul>
</li>
</ul>
<h4 id="子向父—-通过事件关系"><a href="#子向父—-通过事件关系" class="headerlink" title="子向父—-通过事件关系"></a>子向父—-通过事件关系</h4><ul>
<li><p>父:监听自己，添加事件makeon</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    makeon()&#123;</span><br><span class="line">        this.$on(&apos;eat&apos;,fn(msg)&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">this.$on(&apos;eat&apos;,fn(msg)&#123;&#125;) //多次触发</span><br><span class="line">this.$onece(&apos;eat&apos;,fn(msg)&#123;&#125;) //触发一次</span><br><span class="line">this.$on(&apos;eat&apos;,fn(msg)&#123;     </span><br><span class="line">    逻辑代码</span><br><span class="line">    this.$off(&apos;eat&apos;);  // 只触发一次</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>子：添加通知父组件事件 notice</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    notice()&#123;</span><br><span class="line">        this.$parent.$emit(&apos;eat&apos;, &apos;msg&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h4><ul>
<li>1: 下载该插件<code>npm i vue-router</code></li>
<li>2: 在main.js中引入该插件对象</li>
<li>3: 全局安装该插件 <code>Vue.use(插件对象)</code> <ul>
<li>3.1通过install函数给Vue原型挂载属性，未来this.属性就能使用功能</li>
</ul>
</li>
<li>4: 将router配置路由规则(创建路由对象)</li>
<li>5: 将router配置进Vue的options中</li>
<li>6: 留坑 <code>&lt;router-view&gt;&lt;/router-view&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   // 引入该插件</span><br><span class="line">import VueRouter from &apos;vue-router&apos;;</span><br><span class="line"></span><br><span class="line">import Home from &apos;./home.vue&apos;;</span><br><span class="line">//安装插件</span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line">//创建路由对象配置规则</span><br><span class="line">let router = new VueRouter();</span><br><span class="line">router.addRoutes([&#123;</span><br><span class="line">    path:&apos;/home&apos;,</span><br><span class="line">    component: Home</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    path:&apos;/&apos;,     </span><br><span class="line">    redirect:&apos;/hmoe&apos;  //空的时候，重定向到home</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><ul>
<li>router-link指令: to的属性，to=”/xxx” -&gt; path:’/xxx’</li>
<li>:to 绑定属性则可以使用命名路由来匹配路由规则，方便url的更改维护<ul>
<li>:to=”{name:’home’}” -&gt; 规则:{name:’home’,path:’/home’} -&gt;href=”/home”</li>
</ul>
</li>
</ul>
<h4 id="参数router-link"><a href="#参数router-link" class="headerlink" title="参数router-link"></a>参数router-link</h4><ul>
<li>params 、query</li>
<li>命名路由名称不要相同</li>
<li>路由规则: <code>{name:&#39;home&#39;,path:&#39;/home/:who&#39;,component:组件对象}</code><ul>
<li><code>router-link :to=&quot;{name:&#39;home&#39;,params:{who:&#39;xxx&#39;} }&quot;</code></li>
<li><code>href=&quot;/home/xxx&quot;</code></li>
</ul>
</li>
<li>query: <code>{name:&#39;home2&#39;,path:&#39;/home&#39;,component:组件对象}</code><ul>
<li><code>router-link :to=&quot;{name:&#39;home&#39;,query:{who:&#39;xxx&#39;} }&quot;</code></li>
<li><code>href=&quot;/home?who=xxx&quot;</code></li>
</ul>
</li>
<li>获取路由参数: <code>this.$route.params||query.属性名</code><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Axios from &apos;axios&apos;;</span><br><span class="line"></span><br><span class="line">Vue.prototype.$ajax = Axios;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, created() &#123;</span><br><span class="line">        this.$ajax.get(&apos;/v2/movie/in_theaters&apos;)</span><br><span class="line">            .then(function(res) &#123;</span><br><span class="line">                console.log(res);</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul>
<li>beforeCreate 实例初试化后</li>
<li>Created 实例创建完成后 vue实例对象完成了属性的监视、事件的初始化</li>
<li>beforeMount 挂载开始前</li>
<li>Mounted el被vm.$el替换，并挂载到实例上之后 此时可以使用$refs来获取DOM</li>
<li>beforeUpdate 数据更新时</li>
<li>updated 数据更改后</li>
<li>activated keep-alive 组件激活时调用</li>
<li>deactivated keep-alive 组件停用时调用</li>
<li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用</li>
<li>destroyed Vue 实例销毁后调用。<ul>
<li>调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><img src="https://cn.vuejs.org/images/lifecycle.png" alt="image"></li>
</ul>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="ture">
                <source type="audio/mpeg" src="http://isure.stream.qqmusic.qq.com/C4000019tmTw1qJRTO.m4a?guid=4477021994&vkey=3D5E54928074057E5B5CD665CF0158519F587F2565D6D34A0091D495951D91C98AC999A382741BEF7F88443491FB3187754CB2302E126093&uin=6389&fromtag=66">
            </audio>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci="" data-cs="" data-r="fzb920" data-o="fzb920" data-a="" data-d="false">查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>